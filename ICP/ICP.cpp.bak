// icp.cpp 
// Author: JJ

// C++ 
#include <iostream>
#include <chrono>
#include <stack>
#include <random>
#include <numeric>

// OpenCV 
#include <opencv2\opencv.hpp>

// OpenGL Extension Wrangler
#include <GL/glew.h> 
#include <GL/wglew.h> //WGLEW = Windows GL Extension Wrangler (change for different platform) 

// GLFW toolkit
#include <GLFW/glfw3.h>

// OpenGL math
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>

// OpenGL textures
#include <gli/gli.hpp>

//project includes...
#include "globals.h"
#include "init.h"
#include "callbacks.h"
#include "glerror.h" // Check for GL errors

#include "lua_engine.h"
#include "lua_interface.h"

#include "gl_draw.h"
#include "mesh.h"
#include "mesh_init.h"

#include "OBJloader.h"
#include "texture.h"

#include "shaders.h"

// forward declarations
static void init_cv(void);

static void init(void);
void process_video(cv::VideoCapture& capture, std::atomic<glm::vec2>& center_relative);
glm::vec2 process_frame(cv::Mat& frame);
// end of forward declarations


//mesh
mesh mesh_circle;
int circle_segments = 1'000;
mesh mesh_cube;
unsigned int draw_method;

//shaders toon_shader;
shaders basic_shader;
bool shader_ready = false;

struct vertex {
	glm::vec3 position;
	glm::vec4 color;
};

std::vector<vertex> vertices = { 
	{glm::vec3(5000, 0, 5000),glm::vec4(0.5f, 0.5f, 0.5f, 1.0f)},
	{glm::vec3(5000, 0, -5000),glm::vec4(0.5f, 0.5f, 0.5f, 1.0f)},
	{glm::vec3(-5000, 0, -5000),glm::vec4(0.5f, 0.5f, 0.5f, 1.0f)},
	{glm::vec3(-5000, 0, 5000),glm::vec4(0.5f, 0.5f, 0.5f, 1.0f)}
};
//std::vector<GLuint> indices = { 0,1,2,0,2,3 };
//std::vector<GLuint> indices = { 0,1,1,2,2,3,3,0 };
std::vector<GLuint> indices = { 1,2,2,3,3,4,4,1 };

GLuint VAO;

void draw_scene(glm::vec2 & local_center_relative)
{
	// Time measurement, FPS count etc.
	static double time_fps_old = 0.0;
	static double time_frame_old = 0.0;
	static int frame_cnt = 0;
	double time_current, time_frame_delta;

	time_current = glfwGetTime();
	time_frame_delta = time_current - time_frame_old;
	time_frame_old = time_current;

	//FPS
	if (time_current - time_fps_old > 1.0)
	{
		time_fps_old = time_current;
		std::cout << "FPS: " << frame_cnt << std::endl;
		frame_cnt = 0;
	}
	frame_cnt++;

	//
	// DRAW
	//

	// Set the camera
	glm::mat4 mv_m = glm::lookAt(glm::vec3(5000.0f, 500.0f, 5000.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
	//glLoadMatrixf(glm::value_ptr(mv_m));
	{
		GLint loc = glGetUniformLocation(basic_shader.ID, "uMV_m");
		glUniformMatrix4fv(loc, 1, GL_FALSE, glm::value_ptr(mv_m));
	}
	//// plane
	glBindVertexArray(VAO);
	//glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);
	glDrawElements(GL_LINES, indices.size(), GL_UNSIGNED_INT, 0);
	glBindVertexArray(0);


	// circle and cube have size cca 1.0f, need to rescale
	mv_m = glm::scale(mv_m, glm::vec3(1000.0f));
	//glLoadMatrixf(glm::value_ptr(mv_m));

	// draw yellow cube = SUN
	//glColor3f(1.0f, 1.0f, 0.5f);
	//mesh_draw_arrays(mesh_cube);

	//toon_shader.activate();

	// draw green cube = EARTH, modify and restore position + scale
	{
		float angle = glm::radians(glfwGetTime() * 100.0f);
		auto new_pos = mv_m;
		new_pos = glm::rotate(new_pos, angle, glm::vec3(0.0f, 1.0f, 0.0f));
		new_pos = glm::translate(new_pos, glm::vec3(3.0f, 0.0f, 0.0f));
		new_pos = glm::scale(new_pos, glm::vec3(0.5f));
		//glLoadMatrixf(glm::value_ptr(new_pos));

		//glColor3f(0.5f, 1.0f, 0.5f);
		//mesh_draw_arrays(mesh_cube);

		//glLoadMatrixf(glm::value_ptr(mv_m));
	}
	//toon_shader.deactivate();
}

static void init_mesh(void)
{
	GLuint EBO, VBO;
	// Generate the VAO and VBO
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);
	// Bind VAO (set as the current)
	glBindVertexArray(VAO);
	// Bind the VBO, set type as GL_ARRAY_BUFFER
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	// Fill-in data into the VBO
	glBufferData(GL_ARRAY_BUFFER, vertices.size()*sizeof(vertex), vertices.data(), GL_STATIC_DRAW);
	// Bind EBO, set type GL_ELEMENT_ARRAY_BUFFER
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	// Fill-in data into the EBO
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), indices.data(), GL_STATIC_DRAW);
	// Set Vertex Attribute to explain OpenGL how to interpret the VBO
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glm::vec3), (void*)(0 + offsetof(vertex, position)));
	// Enable the Vertex Attribute 0 = position
	glEnableVertexAttribArray(0);

	glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(glm::vec4), (void*)(0 + offsetof(vertex, color)));
	glEnableVertexAttribArray(1);

	// Bind VBO and VAO to 0 to prevent unintended modification of VAO,VBO
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	//mesh_circle = gen_mesh_circle(1.0f, circle_segments);
	//std::cout << "Mesh: CIRCLE initialized, vertices: " << mesh_circle.vertices.size() << ", indices: " << mesh_circle.indices.size() << std::endl;

	//if (!loadOBJ(mesh_cube, "resources/obj/cube_triangles_normals_tex.obj"))
	//{
	//	std::cerr << "loadOBJ failed" << std::endl;
	//	exit(EXIT_FAILURE);
	//}
	//std::cout << "Mesh: CUBE initialized, vertices: " << mesh_cube.vertices.size() << ", indices: " << mesh_cube.indices.size() << std::endl;
	for (auto& v : vertices)
	{
		std::cout << v.position.x << ',' << v.position.y << ',' << v.position.z << std::endl;
		std::cout << v.color.r << ',' << v.color.g << ',' << v.color.b << ',' << v.color.a << std::endl;
	}

	for (auto & i: indices)
		std::cout << i;
}

//---------------------------------------------------------------------
// MAIN
//---------------------------------------------------------------------
cv::Mat frame;
std::atomic<bool> new_frame(false);

int main(int argc, char* argv[])
{
	std::thread camera_thread;
	std::atomic<glm::vec2> center_relative;
	glm::vec2 local_center_relative(0.0f,0.0f);
	cv::Mat local_frame;
	int gl_frame_count(0);
	double current_time, last_fps_time = glfwGetTime();

	init(); //all initializations, including camera
	init_mesh();
	//toon_shader = shaders("resources/shaders/toon.vert", "resources/shaders/toon.frag");
	basic_shader = shaders("resources/shaders/basic.vert", "resources/shaders/basic.frag");
	basic_shader.activate();
	shader_ready = true;

	camera_thread = std::thread(process_video, std::ref(globals.capture), std::ref(center_relative));

	// Main application loop:
	// Run until exit is requested.
	while (!glfwWindowShouldClose(globals.window))
	{
		// Clear color buffer
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		// Use ModelView matrix for following trasformations (translate,rotate,scale)
		//glMatrixMode(GL_MODELVIEW);

		// Render here 
		{
			if (new_frame) {
				frame.copyTo(local_frame);
				local_center_relative = center_relative;
				new_frame = false;

				// flip image vertically: screen coordinates and GL world coordinates have opposite Y-axis orientation
				cv::flip(local_frame, local_frame, 0);
				local_center_relative.y = 1.0f + -1.0f * local_center_relative.y;
			}
			{
				// show image using GL, simple method, direct pixel copy
				//glRasterPos2i(0, 0);
				//glDrawPixels(local_frame.cols, local_frame.rows, GL_BGR, GL_UNSIGNED_BYTE, local_frame.data);
			}
		}

		draw_scene(local_center_relative);
		// ...

		// Swap front and back buffers 
		// Calls glFlush() inside
		glfwSwapBuffers(globals.window);

		// Check OpenGL errors
		gl_check_error();

		// Poll for and process events
		glfwPollEvents();
	}

	if (camera_thread.joinable())
		camera_thread.join();

	finalize(EXIT_SUCCESS);
}

void process_video(cv::VideoCapture& capture, std::atomic<glm::vec2>& center_relative)
{
	cv::Mat local_frame;
	glm::vec2 temp_center;
	int camera_frame_count(0);
	double last_fps_time = glfwGetTime(), current_time;

	while (!glfwWindowShouldClose(globals.window))
	{
		if (capture.read(local_frame))
		{
			temp_center = process_frame(local_frame);

			//atomic assignments
			if (!new_frame) {
				center_relative = temp_center;
				local_frame.copyTo(frame);
				new_frame = true;
			}
			camera_frame_count++;

			// print camera analyzer FPS
			current_time = glfwGetTime();
			if (current_time - last_fps_time > 1.0)
			{
				std::cout << '[' << current_time << ",cam] FPS = " << camera_frame_count / (current_time - last_fps_time) << std::endl;
				last_fps_time = current_time;
				camera_frame_count = 0;
			}
		}
		else
			glfwSetWindowShouldClose(globals.window, true);
	}
}

glm::vec2 process_frame(cv::Mat& frame)
{
	glm::vec2 result(0.0f, 0.0f);

	// load clasifier
	cv::CascadeClassifier face_cascade = cv::CascadeClassifier("resources/haarcascade_frontalface_default.xml");

	// find face
	cv::Mat scene_gray;
	cv::cvtColor(frame, scene_gray, cv::COLOR_BGR2GRAY);
	std::vector<cv::Rect> faces;
	face_cascade.detectMultiScale(scene_gray, faces);
	if (faces.size() > 0)
	{
		result.x = (faces[0].x + (faces[0].width / 2.0f)) / frame.cols;
		result.y = (faces[0].y + (faces[0].height / 2.0f)) / frame.rows;
	}

	// DO NOT DISPLAY! Must not create any OpenCV window!
	// NO! cv::imshow("grabbed", frame);
	// DO NOT POLL EVENTS! Must not call cv::waitKey(), it would steal events from GLFW main loop!
	// NO! cv::waitKey(1);

	return result;
}

static void init(void)
{
	init_cv();
	init_glfw();
	init_glew();
	gl_print_info();
	glEnable(GL_DEPTH_TEST);
}

static void init_cv(void)
{
	globals.capture = cv::VideoCapture(cv::CAP_DSHOW);

	if (!globals.capture.isOpened())
	{
		std::cerr << "no camera" << std::endl;
		exit(EXIT_FAILURE);
	}
	else
	{
		std::cout << "Initial camera" <<
			": width=" << globals.capture.get(cv::CAP_PROP_FRAME_WIDTH) <<
			", height=" << globals.capture.get(cv::CAP_PROP_FRAME_HEIGHT) <<
			", FPS=" << globals.capture.get(cv::CAP_PROP_FPS) << std::endl;
	}

	if (!globals.capture.set(cv::CAP_PROP_FRAME_WIDTH, 640))
		std::cout << "Failed setting width." << std::endl;
	if (!globals.capture.set(cv::CAP_PROP_FRAME_HEIGHT, 480))
		std::cout << "Failed setting height." << std::endl;
	if (!globals.capture.set(cv::CAP_PROP_FPS, 30))
		std::cout << "Failed setting FPS." << std::endl;

	std::cout << "Camera changed" <<
		": width=" << globals.capture.get(cv::CAP_PROP_FRAME_WIDTH) <<
		", height=" << globals.capture.get(cv::CAP_PROP_FRAME_HEIGHT) <<
		", FPS=" << globals.capture.get(cv::CAP_PROP_FPS) << std::endl;
}

//
//PLEASE IGNORE NOW: callbacks
//
void cursor_position_callback(GLFWwindow* window, double xpos, double ypos) {};
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {};

void error_callback(int error, const char* description)
{
	std::cerr << "Error: " << description << std::endl;
}



void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	static GLfloat point_size = 1.0f;

	if ((action == GLFW_PRESS) || (action == GLFW_REPEAT))
	{
		switch (key) {
		case GLFW_KEY_ESCAPE: //fallthrough
		case GLFW_KEY_Q:
			glfwSetWindowShouldClose(window, GL_TRUE);
			break;
		case GLFW_KEY_0:
			draw_method = 0;
			std::cout << "Draw method: vertex for-loop" << std::endl;
			break;
		case GLFW_KEY_1:
			draw_method = 1;
			std::cout << "Draw method: arrays" << std::endl;
			break;
		case GLFW_KEY_2:
			draw_method = 2;
			std::cout << "Draw method: indirect for-loop" << std::endl;
			break;
		case GLFW_KEY_3:
			draw_method = 3;
			std::cout << "Draw method: indirect arrays" << std::endl;
			break;
		case GLFW_KEY_9:
			draw_method = 9;
			std::cout << "Draw method: computational" << std::endl;
			break;
		default:
			break;
		}
	}
}

void fbsize_callback(GLFWwindow* window, int width, int height)
{
	// check for limit case (prevent division by 0)
	if (height == 0)
		height = 1;

	float ratio = width * 1.0f / height;

	globals.width = width;
	globals.height = height;

	//glMatrixMode(GL_PROJECTION);				// set projection matrix for following transformations

	//glLoadIdentity();							// clear all transformations
	//glOrtho(0, width, 0, height, -1000, 1000);  // set Orthographic projection
	//glScalef(1, -1, 1);							// invert Y-axis, so that values decrease in downwards direction to be same as OS coordinates
	//glTranslatef(0, -height, 0);				// shift the origin to bottom left corner 

	glm::mat4 projectionMatrix = glm::perspective(
		glm::radians(60.0f), // The vertical Field of View, in radians: the amount of "zoom". Think "camera lens". Usually between 90° (extra wide) and 30° (quite zoomed in)
		ratio,			     // Aspect Ratio. Depends on the size of your window.
		0.1f,                // Near clipping plane. Keep as big as possible, or you'll get precision issues.
		20000.0f              // Far clipping plane. Keep as little as possible.
	);
	//glLoadMatrixf(glm::value_ptr(projectionMatrix));
	if (shader_ready)
		glUniformMatrix4fv(glGetUniformLocation(basic_shader.ID, "uProj_m"), 1, GL_FALSE, glm::value_ptr(projectionMatrix));

	glViewport(0, 0, width, height);			// set visible area
}
